# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with
code in this repository.

## Project Overview

**tsfga** is a TypeScript library that implements OpenFGA-compatible
relationship-based access control (ReBAC). It provides a 5-step recursive
check algorithm, CEL condition support, and a database-agnostic architecture
with a Kysely adapter for PostgreSQL.

### Scope

**In scope:**
- Core check algorithm (5-step recursive)
- CRUD operations for tuples, relation configs, and condition definitions
- CEL condition evaluation via `@marcbachmann/cel-js`
- Kysely adapter for PostgreSQL
- Conformance testing against real OpenFGA

**Out of scope:**
- DSL parsing (use `@openfga/syntax-transformer` in tests)
- HTTP server / API layer
- Multi-tenant store isolation
- Watch / streaming APIs

## Architecture

```
createTsfga (public API)
  ↓
check / conditions (core algorithm)
  ↓
TupleStore (interface)
  ↓
KyselyTupleStore (adapter)
```

**Key rule:** `src/core/` never imports from `src/store/kysely/`. The core
algorithm depends only on the `TupleStore` interface.

## Directory Structure

```
tsfga/
├── src/
│   ├── core/                    # Pure logic, no DB dependencies
│   │   ├── check.ts             # 5-step recursive check algorithm
│   │   ├── conditions.ts        # CEL condition evaluation
│   │   ├── types.ts             # All shared types
│   │   └── errors.ts            # Error hierarchy
│   ├── store/
│   │   ├── interface.ts         # TupleStore interface definition
│   │   └── kysely/
│   │       ├── adapter.ts       # KyselyTupleStore implements TupleStore
│   │       ├── schema.ts        # Generated by kysely-codegen (DO NOT HAND-EDIT)
│   │       └── migrations/
│   │           └── 001-initial.ts
│   └── index.ts                 # Public API: createTsfga()
├── tests/
│   ├── core/                    # Unit tests (mock store)
│   │   ├── check.test.ts
│   │   └── conditions.test.ts
│   ├── store/                   # Integration tests (real PostgreSQL)
│   │   └── kysely-adapter.test.ts
│   ├── conformance/             # OpenFGA conformance tests
│   │   ├── slack.test.ts
│   │   └── slack/
│   │       ├── model.dsl        # OpenFGA DSL model
│   │       └── tuples.yaml      # Relationship tuples
│   └── helpers/
│       ├── mock-store.ts        # In-memory TupleStore for unit tests
│       ├── conformance.ts       # expectConformance() helper
│       ├── openfga.ts           # OpenFGA SDK client operations
│       └── preload.ts           # Infrastructure setup (Docker)
├── compose.yaml                 # PostgreSQL + OpenFGA services
├── .env                         # Environment variables
├── package.json
├── tsconfig.json
├── biome.json
├── bunfig.toml
└── CLAUDE.md
```

## Core Types (`src/core/types.ts`)

```typescript
/** A relationship tuple with optional condition */
export interface Tuple {
  objectType: string;
  objectId: string;
  relation: string;
  subjectType: string;
  subjectId: string;
  subjectRelation?: string;
  conditionName?: string;
  conditionContext?: Record<string, unknown>;
}

/** Configuration for a relation on an object type */
export interface RelationConfig {
  objectType: string;
  relation: string;
  directlyAssignableTypes?: string[];
  impliedBy?: string[];
  computedUserset?: string;
  tupleToUserset?: { tupleset: string; computedUserset: string };
  allowsUsersetSubjects: boolean;
}

/** A named CEL condition definition */
export interface ConditionDefinition {
  name: string;
  expression: string;
  parameters: Record<string, ConditionParameterType>;
}

/** Supported CEL parameter types */
export type ConditionParameterType =
  | "string"
  | "int"
  | "bool"
  | "double"
  | "duration"
  | "timestamp"
  | "list"
  | "map";

/** Parameters for a check request */
export interface CheckRequest {
  objectType: string;
  objectId: string;
  relation: string;
  subjectType: string;
  subjectId: string;
  context?: Record<string, unknown>;
}

/** Options for the check algorithm */
export interface CheckOptions {
  /** Maximum recursion depth (default: 10) */
  maxDepth?: number;
}

/** Parameters for adding a tuple */
export interface AddTupleRequest {
  objectType: string;
  objectId: string;
  relation: string;
  subjectType: string;
  subjectId: string;
  subjectRelation?: string;
  conditionName?: string;
  conditionContext?: Record<string, unknown>;
}

/** Parameters for removing a tuple */
export interface RemoveTupleRequest {
  objectType: string;
  objectId: string;
  relation: string;
  subjectType: string;
  subjectId: string;
  subjectRelation?: string;
}
```

## TupleStore Interface (`src/store/interface.ts`)

The `TupleStore` is the abstraction boundary between the core algorithm and any
database backend. All methods return `Promise`.

```typescript
export interface TupleStore {
  // === Read ===

  /** Check if a direct tuple exists (no subject_relation) */
  findDirectTuple(
    objectType: string,
    objectId: string,
    relation: string,
    subjectType: string,
    subjectId: string,
  ): Promise<Tuple | null>;

  /** Find tuples where subject_relation IS NOT NULL (userset expansion) */
  findUsersetTuples(
    objectType: string,
    objectId: string,
    relation: string,
  ): Promise<Tuple[]>;

  /** Find tuples by object + relation (for tuple-to-userset tupleset lookup) */
  findTuplesByRelation(
    objectType: string,
    objectId: string,
    relation: string,
  ): Promise<Tuple[]>;

  /** Get relation config for an object_type + relation */
  findRelationConfig(
    objectType: string,
    relation: string,
  ): Promise<RelationConfig | null>;

  /** Get a condition definition by name */
  findConditionDefinition(name: string): Promise<ConditionDefinition | null>;

  // === Write ===

  /** Insert or update a tuple (upsert on natural key) */
  insertTuple(tuple: AddTupleRequest): Promise<void>;

  /** Delete a tuple by natural key */
  deleteTuple(tuple: RemoveTupleRequest): Promise<boolean>;

  // === Query ===

  /** List candidate object IDs for list_objects (pre-filter, check still required) */
  listCandidateObjectIds(
    objectType: string,
  ): Promise<string[]>;

  /** List direct subjects for an object + relation */
  listDirectSubjects(
    objectType: string,
    objectId: string,
    relation: string,
  ): Promise<Array<{ subjectType: string; subjectId: string; subjectRelation?: string }>>;

  // === Config management ===

  /** Insert or update a relation config */
  upsertRelationConfig(config: RelationConfig): Promise<void>;

  /** Delete a relation config */
  deleteRelationConfig(objectType: string, relation: string): Promise<boolean>;

  /** Insert or update a condition definition */
  upsertConditionDefinition(condition: ConditionDefinition): Promise<void>;

  /** Delete a condition definition */
  deleteConditionDefinition(name: string): Promise<boolean>;
}
```

## Check Algorithm (`src/core/check.ts`)

This is the most critical file. It implements the 5-step recursive
check algorithm for relationship-based access control.

```typescript
export async function check(
  store: TupleStore,
  request: CheckRequest,
  options: CheckOptions = {},
  depth: number = 0,
): Promise<boolean> {
  const maxDepth = options.maxDepth ?? 10;

  // Prevent infinite recursion
  if (depth > maxDepth) {
    return false;
  }

  // Step 1: Direct tuple check
  // Look for exact match: (objectType, objectId, relation, subjectType, subjectId)
  // where subject_relation IS NULL.
  // If the tuple has a conditionName, evaluate the CEL condition.
  // Return true only if no condition or condition evaluates to true.
  const directTuple = await store.findDirectTuple(
    request.objectType, request.objectId, request.relation,
    request.subjectType, request.subjectId,
  );
  if (directTuple) {
    if (await evaluateTupleCondition(store, directTuple, request.context)) {
      return true;
    }
  }

  // Step 2: Userset expansion
  // Find tuples where subject_relation IS NOT NULL.
  // e.g., (channel:proj, writer, workspace:sandcastle#member)
  // For each, recursively check if the user has the subject_relation
  // on the referenced subject object.
  // If the userset tuple has a conditionName, evaluate before recursing.
  const usersetTuples = await store.findUsersetTuples(
    request.objectType, request.objectId, request.relation,
  );
  for (const userset of usersetTuples) {
    if (!await evaluateTupleCondition(store, userset, request.context)) {
      continue;
    }
    const hasRelation = await check(store, {
      objectType: userset.subjectType,
      objectId: userset.subjectId,
      relation: userset.subjectRelation!,
      subjectType: request.subjectType,
      subjectId: request.subjectId,
      context: request.context,
    }, options, depth + 1);
    if (hasRelation) {
      return true;
    }
  }

  // Fetch once for steps 3-5
  const config = await store.findRelationConfig(
    request.objectType, request.relation,
  );

  // Step 3: Relation inheritance (implied_by)
  // e.g., checking "member" and config says implied_by: ["channels_admin"]
  // → recursively check if user has "channels_admin" on the same object
  if (config?.impliedBy) {
    for (const impliedRelation of config.impliedBy) {
      const hasRelation = await check(store, {
        ...request,
        relation: impliedRelation,
      }, options, depth + 1);
      if (hasRelation) {
        return true;
      }
    }
  }

  // Step 4: Computed userset
  // e.g., for branch.can_merge, computed_userset = "can_push" means
  // users who can push can also merge (on the same object)
  if (config?.computedUserset) {
    const hasRelation = await check(store, {
      ...request,
      relation: config.computedUserset,
    }, options, depth + 1);
    if (hasRelation) {
      return true;
    }
  }

  // Step 5: Tuple-to-userset
  // e.g., for repo.read with ttu = {tupleset: "organization", computed_userset: "member"}
  // Find tuples (repo, objectId, "organization", ?, ?) to get the linked org,
  // then check if user has "member" on that org.
  if (config?.tupleToUserset) {
    const { tupleset, computedUserset } = config.tupleToUserset;
    const linkedTuples = await store.findTuplesByRelation(
      request.objectType, request.objectId, tupleset,
    );
    for (const linked of linkedTuples) {
      const hasRelation = await check(store, {
        objectType: linked.subjectType,
        objectId: linked.subjectId,
        relation: computedUserset,
        subjectType: request.subjectType,
        subjectId: request.subjectId,
        context: request.context,
      }, options, depth + 1);
      if (hasRelation) {
        return true;
      }
    }
  }

  return false;
}
```

**Critical implementation notes:**
- Steps 3, 4, 5 all use the SAME `config` fetched once
- Do NOT merge `impliedBy` and `computedUserset` into one concept; they are
  distinct OpenFGA features
- The `depth` parameter is internal; it is not exposed in the public API
- `maxDepth` defaults to 10 but is configurable via `CheckOptions`

## CEL Conditions (`src/core/conditions.ts`)

Uses `@marcbachmann/cel-js` to evaluate Common Expression Language conditions on
tuples.

```typescript
import { Environment } from "@marcbachmann/cel-js";

/** Cache compiled CEL environments by condition name */
const envCache = new Map<string, Environment>();

/**
 * Evaluate a tuple's condition. Returns true if:
 * - The tuple has no condition (unconditional access)
 * - The condition evaluates to true
 * Returns false if the condition evaluates to false.
 * Throws ConditionNotFoundError if conditionName references a missing definition.
 * Throws ConditionEvaluationError if CEL evaluation fails.
 */
export async function evaluateTupleCondition(
  store: TupleStore,
  tuple: Tuple,
  requestContext?: Record<string, unknown>,
): Promise<boolean> {
  if (!tuple.conditionName) {
    return true; // No condition = unconditional access
  }

  const condDef = await store.findConditionDefinition(tuple.conditionName);
  if (!condDef) {
    throw new ConditionNotFoundError(tuple.conditionName);
  }

  // Merge contexts: request context wins over tuple context
  const context = { ...tuple.conditionContext, ...requestContext };

  let env = envCache.get(condDef.name);
  if (!env) {
    env = new Environment();
    envCache.set(condDef.name, env);
  }

  try {
    const result = env.evaluate(condDef.expression, context);
    return result === true;
  } catch (error) {
    throw new ConditionEvaluationError(condDef.name, error);
  }
}
```

**Context merge rule:** `requestContext` properties override
`tuple.conditionContext` properties. This matches OpenFGA behavior where the
check request context takes precedence.

## Error Types (`src/core/errors.ts`)

```typescript
export class TsfgaError extends Error {
  constructor(message: string) {
    super(message);
    this.name = "TsfgaError";
  }
}

export class RelationConfigNotFoundError extends TsfgaError {
  constructor(objectType: string, relation: string) {
    super(`No relation config found for ${objectType}.${relation}`);
    this.name = "RelationConfigNotFoundError";
  }
}

export class InvalidSubjectTypeError extends TsfgaError {
  constructor(subjectType: string, objectType: string, relation: string, allowed: string[]) {
    super(
      `Subject type '${subjectType}' is not allowed for ${objectType}.${relation}. Allowed: ${allowed.join(", ")}`,
    );
    this.name = "InvalidSubjectTypeError";
  }
}

export class UsersetNotAllowedError extends TsfgaError {
  constructor(objectType: string, relation: string) {
    super(`Userset subjects are not allowed for ${objectType}.${relation}`);
    this.name = "UsersetNotAllowedError";
  }
}

export class ConditionNotFoundError extends TsfgaError {
  constructor(conditionName: string) {
    super(`Condition definition not found: ${conditionName}`);
    this.name = "ConditionNotFoundError";
  }
}

export class ConditionEvaluationError extends TsfgaError {
  cause: unknown;
  constructor(conditionName: string, cause: unknown) {
    super(`Failed to evaluate condition '${conditionName}': ${cause}`);
    this.name = "ConditionEvaluationError";
    this.cause = cause;
  }
}
```

## Kysely Adapter (`src/store/kysely/`)

### Migration (`src/store/kysely/migrations/001-initial.ts`)

Creates the `tsfga` schema with 3 tables and 6 indexes. Uses Kysely's DDL
schema builder API where possible; raw `sql` only for indexes the builder
cannot express.

**Pattern:** Prefer `db.schema.createTable()` / `db.schema.createIndex()` over
raw SQL. Use `sql` template literals only when the builder API cannot express
the DDL (expression indexes, GIN + WHERE combos).

**What stays as raw SQL:**
- `idx_tuples_unique` — uses `COALESCE(subject_relation, '')` expression
- `idx_tuples_metadata` — uses `USING GIN` with a `WHERE` clause

**Migration management** uses `kysely-ctl` with config in `kysely.config.ts`:
- `bun run db:latest` — apply all pending migrations
- `bun run db:rollback` — rollback all migrations

**Schema produced:**

```sql
-- tsfga.tuples: relationship tuples with optional conditions
-- tsfga.relation_configs: relation definitions (implied_by, computed_userset, etc.)
-- tsfga.condition_definitions: named CEL condition expressions
-- 6 indexes on tsfga.tuples (unique, object, subject, check, userset, metadata, condition)
```

### Schema Generation (`src/store/kysely/schema.ts`)

This file is **generated by `kysely-codegen`** from the actual database schema
after running migrations. **DO NOT hand-edit this file.** Regenerate with:

```bash
bun run db:generate
```

The generation workflow:
1. Write/modify migrations in `src/store/kysely/migrations/`
2. Start Docker: `bun run infra:up`
3. Run migrations against dev DB
4. Run `kysely-codegen` to regenerate `schema.ts`
5. Commit the generated file (so consumers don't need kysely-codegen)

### Adapter (`src/store/kysely/adapter.ts`)

`KyselyTupleStore` implements `TupleStore`. It receives a `Kysely<DB>` instance
(does NOT own it).

```typescript
export class KyselyTupleStore implements TupleStore {
  constructor(private db: Kysely<DB>) {}
  // ... implements all TupleStore methods
}
```

**UUID mapping:** The DB stores `object_id` and `subject_id` as `uuid`. The
`TupleStore` interface uses `string`. The adapter handles conversion in both
directions. Callers pass UUID-formatted strings
(e.g., `"550e8400-e29b-41d4-a716-446655440000"`).

**DML pattern:** Always use Kysely's type-safe query builder for adapter
methods. Use `onConflict().expression(sql`...`)` (without outer parens) for
upserts against expression indexes. Do not use raw `sql` template literals for
INSERT, SELECT, UPDATE, or DELETE queries.

## Public API (`src/index.ts`)

```typescript
export function createTsfga(store: TupleStore, options?: CheckOptions): TsfgaClient;

export interface TsfgaClient {
  check(request: CheckRequest): Promise<boolean>;
  addTuple(request: AddTupleRequest): Promise<void>;
  removeTuple(request: RemoveTupleRequest): Promise<boolean>;
  listObjects(objectType: string, relation: string, subjectType: string, subjectId: string): Promise<string[]>;
  listSubjects(objectType: string, objectId: string, relation: string): Promise<Array<{ subjectType: string; subjectId: string; subjectRelation?: string }>>;
  writeRelationConfig(config: RelationConfig): Promise<void>;
  deleteRelationConfig(objectType: string, relation: string): Promise<boolean>;
  writeConditionDefinition(condition: ConditionDefinition): Promise<void>;
  deleteConditionDefinition(name: string): Promise<boolean>;
}
```

**Re-exports:** `src/index.ts` also re-exports all types, errors, the `TupleStore`
interface, and `KyselyTupleStore`.

## Conformance Testing

Conformance tests validate that tsfga produces identical results to a real
OpenFGA service. This is the most important testing layer.

### Docker Compose (`compose.yaml`)

Runs PostgreSQL + OpenFGA (with migration sidecar):

```yaml
services:
  postgres:
    image: postgres:18-alpine
    ports:
      - ${POSTGRES_PORT}:5432
    environment:
      POSTGRES_DB: ${POSTGRES_DB}
      POSTGRES_USER: ${POSTGRES_USER}
      POSTGRES_PASSWORD: ${POSTGRES_PASSWORD}
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U $${POSTGRES_USER} -d $${POSTGRES_DB}"]
      interval: 10s
      retries: 5
      start_period: 30s
      timeout: 10s

  openfga-migrate:
    depends_on:
      postgres:
        condition: service_healthy
    image: openfga/openfga:latest
    environment:
      - OPENFGA_DATASTORE_ENGINE=postgres
      - OPENFGA_DATASTORE_URI=postgres://${POSTGRES_USER}:${POSTGRES_PASSWORD}@postgres:5432/${POSTGRES_DB}?sslmode=disable&search_path=openfga
    command: migrate

  openfga:
    depends_on:
      openfga-migrate:
        condition: service_completed_successfully
    image: openfga/openfga:latest
    command: run
    environment:
      - OPENFGA_DATASTORE_ENGINE=postgres
      - OPENFGA_DATASTORE_URI=postgres://${POSTGRES_USER}:${POSTGRES_PASSWORD}@postgres:5432/${POSTGRES_DB}?sslmode=disable&search_path=openfga
      - OPENFGA_PLAYGROUND_ENABLED=true
    ports:
      - "8080:8080"
      - "8081:8081"
      - "3000:3000"
    healthcheck:
      test: ["CMD", "/usr/local/bin/grpc_health_probe", "-addr=openfga:8081"]
      interval: 5s
      timeout: 30s
      retries: 3
```

OpenFGA uses its own `openfga` schema in the same PostgreSQL instance. tsfga
uses the `tsfga` schema. They share the database but not schema.

### Environment (`.env`)

```
POSTGRES_DB=dev
POSTGRES_HOST=localhost
POSTGRES_PASSWORD=password
POSTGRES_PORT=5432
POSTGRES_USER=dev
FGA_API_URL=http://localhost:8080
PREFIX=tsfga
```

All configuration comes from environment variables (loaded from `.env` by Bun).
**Never hard-code default values** in `process.env` reads — use bare
`process.env.VAR_NAME`, not `process.env.VAR_NAME || "fallback"`. Defaults
belong in `.env` only, so there is a single source of truth.

### Test Preload (`tests/helpers/preload.ts`)

```typescript
import { checkInfrastructure } from "tests/helpers/infrastructure.ts";
await checkInfrastructure();
```

`checkInfrastructure()` does:
1. Poll PostgreSQL with `SELECT 1` (up to 5 retries)
2. Poll OpenFGA with `GET /stores` (up to 5 retries)
3. Fail with actionable error if services are not reachable

Infrastructure must be started before running tests:
```bash
bun run infra:setup    # First time: starts services + runs migrations
bun run infra:up       # Subsequent runs: starts services only
```

### OpenFGA Helpers (`tests/helpers/openfga.ts`)

```typescript
import { OpenFgaClient } from "@openfga/sdk";
import { transformer } from "@openfga/syntax-transformer";
import { parse as parseYaml } from "yaml";

export function createClient(storeId?: string): OpenFgaClient;
export async function fgaCreateStore(name: string): Promise<string>;
export async function fgaWriteModel(storeId: string, modelPath: string): Promise<string>;
export async function fgaWriteTuples(storeId: string, tuplesPath: string): Promise<void>;
export async function fgaCheck(storeId: string, params: CheckParams): Promise<boolean | null>;
```

### Conformance Helper (`tests/helpers/conformance.ts`)

```typescript
import { expect } from "bun:test";

/**
 * Assert that tsfga and OpenFGA return the same result for a permission check.
 * Runs both checks in parallel for speed.
 */
export async function expectConformance(
  storeId: string,
  tsfgaClient: TsfgaClient,
  params: CheckRequest,
  expected: boolean,
): Promise<void> {
  const [tsfgaResult, openFgaResult] = await Promise.all([
    tsfgaClient.check(params),
    fgaCheck(storeId, {
      objectType: params.objectType,
      objectId: params.objectId,
      relation: params.relation,
      subjectType: params.subjectType,
      subjectId: params.subjectId,
    }),
  ]);

  if (openFgaResult === null) {
    throw new Error("OpenFGA returned an error");
  }

  // Both systems must agree
  expect(tsfgaResult).toBe(openFgaResult);
  // And match expected value
  expect(tsfgaResult).toBe(expected);
}
```

### Conformance Test File (`tests/conformance/slack.test.ts`)

```typescript
import { afterAll, beforeAll, describe, test } from "bun:test";
import { createTsfga, KyselyTupleStore } from "src/index.ts";
import { expectConformance } from "tests/helpers/conformance.ts";
import { fgaCreateStore, fgaWriteModel, fgaWriteTuples } from "tests/helpers/openfga.ts";

describe("Slack Model Conformance", () => {
  let storeId: string;
  let tsfgaClient: TsfgaClient;

  beforeAll(async () => {
    // Setup tsfga: create KyselyTupleStore, load relation configs + tuples
    const store = new KyselyTupleStore(db);
    tsfgaClient = createTsfga(store);

    // Write relation configs matching the Slack model
    // Write tuples matching tests/conformance/slack/tuples.yaml

    // Setup OpenFGA
    storeId = await fgaCreateStore("slack-test");
    await fgaWriteModel(storeId, "tests/conformance/slack/model.dsl");
    await fgaWriteTuples(storeId, "tests/conformance/slack/tuples.yaml");
  });

  // ... 28 check assertions using expectConformance()
});
```

### Test Scope

- **Slack model**: 28 checks (workspace + channel relations, userset expansion)
- **GitHub model**: 50+ checks (organization, team, repo relations, tuple-to-userset)

## Dependencies

### Runtime
- `@marcbachmann/cel-js` - CEL expression evaluation

### Peer
- `kysely` >= 0.27.0 - Query builder
- `pg` >= 8.0.0 - PostgreSQL driver

### Dev
- `@biomejs/biome` - Linter + formatter
- `@types/bun` - Bun type definitions
- `typescript` - Type checking
- `kysely-codegen` - Generate Kysely types from DB schema
- `@openfga/sdk` - OpenFGA client for conformance tests
- `@openfga/syntax-transformer` - DSL to JSON for conformance tests
- `yaml` - Parse tuples.yaml files

## Dev Commands

```bash
bun install                              # Install dependencies
bun run infra:up                         # Start Docker services
bun run infra:down                       # Tear down Docker services + volumes
bun run infra:setup                      # Start services + run migrations
bun run test                             # All tests (infra must be running)
bun test tests/core/                     # Unit tests only (no infra needed)
bun test tests/conformance/              # Conformance tests (infra must be running)
bun test tests/store/                    # Integration tests (infra must be running)
bun run tsc                              # Type check
bun run biome:check                      # Lint + format check
bun run biome:lint                       # Lint only
bun run biome:format                     # Format fix
bun run db:generate                      # Regenerate Kysely types from DB
bun run db:latest                        # Apply pending migrations
bun run db:rollback                      # Rollback all migrations
```

### Type Generation Workflow

```bash
# 1. Modify migrations
#    Edit src/store/kysely/migrations/001-initial.ts

# 2. Start PostgreSQL
bun run infra:up

# 3. Run migrations
bun run db:latest

# 4. Regenerate types
bun run db:generate
# This runs: bunx kysely-codegen --out-file src/store/kysely/schema.ts

# 5. Commit the generated schema.ts
```

## Configuration Files

### `kysely.config.ts`

Configuration for `kysely-ctl` migration commands. Reads connection params from
environment variables (falling back to `.env` defaults). Points to migration
files in `src/store/kysely/migrations/`.

### `bunfig.toml`

```toml
[install]
exact = true

[test]
timeout = 120000
preload = ["./tests/helpers/preload.ts"]
```

### `tsconfig.json`

```json
{
  "compilerOptions": {
    "lib": ["ESNext"],
    "target": "ESNext",
    "module": "Preserve",
    "moduleDetection": "force",
    "allowJs": true,
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "verbatimModuleSyntax": true,
    "noEmit": true,
    "strict": true,
    "skipLibCheck": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedIndexedAccess": true,
    "noImplicitOverride": true,
    "noUnusedLocals": false,
    "noUnusedParameters": false,
    "noPropertyAccessFromIndexSignature": false,
    "paths": {
      "src/*": ["./src/*"],
      "tests/*": ["./tests/*"]
    }
  }
}
```

### `biome.json`

```json
{
  "$schema": "https://biomejs.dev/schemas/2.3.13/schema.json",
  "vcs": {
    "enabled": true,
    "clientKind": "git",
    "useIgnoreFile": true
  },
  "files": {
    "ignoreUnknown": false,
    "includes": ["**/*.ts"],
    "ignore": ["src/store/kysely/schema.ts"]
  },
  "formatter": {
    "enabled": true,
    "indentStyle": "space",
    "indentWidth": 2
  },
  "linter": {
    "enabled": true,
    "rules": {
      "recommended": true,
      "complexity": {
        "useLiteralKeys": "off"
      },
      "style": {
        "noRestrictedImports": {
          "level": "error",
          "options": {
            "paths": {
              "pg": {
                "message": "Do not import pg directly in core/. Use the TupleStore interface."
              }
            }
          }
        },
        "useFilenamingConvention": {
          "level": "error",
          "options": {
            "filenameCases": ["kebab-case"]
          }
        }
      }
    }
  },
  "javascript": {
    "formatter": {
      "quoteStyle": "double"
    }
  },
  "assist": {
    "enabled": true,
    "actions": {
      "source": {
        "organizeImports": {
          "level": "on",
          "options": {
            "groups": [
              ":BUN:",
              ":NODE:",
              ":PACKAGE:",
              ":PACKAGE_WITH_PROTOCOL:",
              ":URL:",
              ":ALIAS:",
              ":PATH:"
            ]
          }
        }
      }
    }
  }
}
```

## Git Commit Messages

- **Never** use conventional commit format (`feat:`, `fix:`, `chore:`, etc.)
- Header is a single line of **at most 50 characters**, in imperative
  mood, starting with a capital letter, that meaningfully summarizes
  the change (shown by `gitk`, `git shortlog`)
- Body explains the *why* -- motivation, background, reasoning for the
  chosen approach -- not just *what* changed (the diff shows that)
- Wrap body paragraphs at ~74 columns
- Use imperative verbs: "Fix ...", "Add ...", "Make ...",
  "Refactor ...", "Remove ..."

## Anti-Patterns (DO NOT)

- **No session context coupling.** Always receive `subjectType` and
  `subjectId` explicitly in every check call. There is no global user
  context.
- **No SECURITY DEFINER.** This is a PostgreSQL-specific mechanism for RLS
  bypass. Not applicable to a TypeScript library.
- **Single config fetch for steps 3-5.** Fetch the relation config once
  and read all three fields (implied_by, computed_userset,
  tuple_to_userset) from the result.
- **Don't merge implied_by and computed_userset.** They are distinct OpenFGA
  concepts. `implied_by` means "relation X on the same object type implies this
  relation" (e.g., `channels_admin` implies `member`). `computed_userset` means
  "check a different relation on the same object" (used in GitHub model for
  `can_merge` -> `can_push`).
- **Don't skip condition evaluation on userset tuples.** Both direct tuples
  (step 1) and userset tuples (step 2) can have conditions. Evaluate before
  accepting or recursing.
- **Don't use Kysely types in core/.** The core module must remain
  database-agnostic.
- **No default values for environment variables.** Read `process.env.VAR`
  directly, without `|| "fallback"`. The `.env` file is the single source of
  truth for defaults.
- **No raw SQL for DML in the adapter.** All adapter queries must use
  Kysely's type-safe query builder. The only exception is `sql` expressions
  *within* builder calls (e.g., `onConflict().expression(sql`...`)`).
  Full raw `sql` INSERT/SELECT queries bypass type checking and
  schema validation.

## References

- OpenFGA docs: https://openfga.dev/docs/modeling/getting-started
- OpenFGA conditions: https://openfga.dev/docs/modeling/conditions
- CEL spec: https://github.com/google/cel-spec
- `@marcbachmann/cel-js`: https://github.com/nicholasgasior/cel-js
- Kysely docs: https://kysely.dev/
- kysely-codegen: https://github.com/RobinBlomberg/kysely-codegen
