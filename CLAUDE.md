# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with
code in this repository.

## Project Overview

**tsfga** is a TypeScript library that implements OpenFGA-compatible
relationship-based access control (ReBAC). It ports the check algorithm from
[pgfga](https://github.com/lemuelroberto/poc-pgfga) (a PL/pgSQL PostgreSQL
extension) to TypeScript, adding CEL condition support and a database-agnostic
architecture with a Kysely adapter.

### Lineage

tsfga is a direct port of pgfga's recursive check algorithm. The 5-step check
logic in `src/core/check.ts` must faithfully reproduce the behavior of pgfga's
`pgfga.check()` function. Conformance is validated by running both tsfga and a
real OpenFGA service against identical authorization models and tuples, then
asserting identical results.

### Scope

**In scope:**
- Core check algorithm (5-step recursive)
- CRUD operations for tuples, relation configs, and condition definitions
- CEL condition evaluation via `@marcbachmann/cel-js`
- Kysely adapter for PostgreSQL
- Conformance testing against real OpenFGA

**Out of scope:**
- DSL parsing (use `@openfga/syntax-transformer` in tests)
- HTTP server / API layer
- Multi-tenant store isolation
- Watch / streaming APIs

## Architecture

```
Public API (createTsfga) → Core Algorithm (check, conditions) → TupleStore interface → Kysely adapter
```

**Key rule:** `src/core/` never imports from `src/store/kysely/`. The core
algorithm depends only on the `TupleStore` interface.

## Directory Structure

```
fga-ts/
├── src/
│   ├── core/                    # Pure logic, no DB dependencies
│   │   ├── check.ts             # 5-step recursive check algorithm
│   │   ├── conditions.ts        # CEL condition evaluation
│   │   ├── types.ts             # All shared types
│   │   └── errors.ts            # Error hierarchy
│   ├── store/
│   │   ├── interface.ts         # TupleStore interface definition
│   │   └── kysely/
│   │       ├── adapter.ts       # KyselyTupleStore implements TupleStore
│   │       ├── schema.ts        # Generated by kysely-codegen (DO NOT HAND-EDIT)
│   │       └── migrations/
│   │           └── 001-initial.ts
│   └── index.ts                 # Public API: createTsfga()
├── tests/
│   ├── core/                    # Unit tests (mock store)
│   │   ├── check.test.ts
│   │   └── conditions.test.ts
│   ├── store/                   # Integration tests (real PostgreSQL)
│   │   └── kysely-adapter.test.ts
│   ├── conformance/             # OpenFGA conformance tests
│   │   └── slack.test.ts
│   └── helpers/
│       ├── mock-store.ts        # In-memory TupleStore for unit tests
│       ├── conformance.ts       # expectConformance() helper
│       ├── openfga.ts           # OpenFGA SDK client operations
│       └── preload.ts           # Infrastructure setup (Docker)
├── examples/
│   └── slack/
│       ├── model.dsl            # OpenFGA DSL (reuse from pgfga)
│       └── tuples.yaml          # Relationship tuples (reuse from pgfga)
├── compose.yaml                 # PostgreSQL + OpenFGA services
├── .env                         # Environment variables
├── package.json
├── tsconfig.json
├── biome.json
├── bunfig.toml
└── CLAUDE.md
```

## Core Types (`src/core/types.ts`)

```typescript
/** A relationship tuple with optional condition */
export interface Tuple {
  objectType: string;
  objectId: string;
  relation: string;
  subjectType: string;
  subjectId: string;
  subjectRelation?: string;
  conditionName?: string;
  conditionContext?: Record<string, unknown>;
}

/** Configuration for a relation on an object type */
export interface RelationConfig {
  objectType: string;
  relation: string;
  directlyAssignableTypes?: string[];
  impliedBy?: string[];
  computedUserset?: string;
  tupleToUserset?: { tupleset: string; computedUserset: string };
  allowsUsersetSubjects: boolean;
}

/** A named CEL condition definition */
export interface ConditionDefinition {
  name: string;
  expression: string;
  parameters: Record<string, ConditionParameterType>;
}

/** Supported CEL parameter types */
export type ConditionParameterType =
  | "string"
  | "int"
  | "bool"
  | "double"
  | "duration"
  | "timestamp"
  | "list"
  | "map";

/** Parameters for a check request */
export interface CheckRequest {
  objectType: string;
  objectId: string;
  relation: string;
  subjectType: string;
  subjectId: string;
  context?: Record<string, unknown>;
}

/** Options for the check algorithm */
export interface CheckOptions {
  /** Maximum recursion depth (default: 10) */
  maxDepth?: number;
}

/** Parameters for adding a tuple */
export interface AddTupleRequest {
  objectType: string;
  objectId: string;
  relation: string;
  subjectType: string;
  subjectId: string;
  subjectRelation?: string;
  conditionName?: string;
  conditionContext?: Record<string, unknown>;
}

/** Parameters for removing a tuple */
export interface RemoveTupleRequest {
  objectType: string;
  objectId: string;
  relation: string;
  subjectType: string;
  subjectId: string;
  subjectRelation?: string;
}
```

## TupleStore Interface (`src/store/interface.ts`)

The `TupleStore` is the abstraction boundary between the core algorithm and any
database backend. All methods return `Promise`.

```typescript
export interface TupleStore {
  // === Read ===

  /** Check if a direct tuple exists (no subject_relation) */
  findDirectTuple(
    objectType: string,
    objectId: string,
    relation: string,
    subjectType: string,
    subjectId: string,
  ): Promise<Tuple | null>;

  /** Find tuples where subject_relation IS NOT NULL (userset expansion) */
  findUsersetTuples(
    objectType: string,
    objectId: string,
    relation: string,
  ): Promise<Tuple[]>;

  /** Find tuples by object + relation (for tuple-to-userset tupleset lookup) */
  findTuplesByRelation(
    objectType: string,
    objectId: string,
    relation: string,
  ): Promise<Tuple[]>;

  /** Get relation config for an object_type + relation */
  findRelationConfig(
    objectType: string,
    relation: string,
  ): Promise<RelationConfig | null>;

  /** Get a condition definition by name */
  findConditionDefinition(name: string): Promise<ConditionDefinition | null>;

  // === Write ===

  /** Insert or update a tuple (upsert on natural key) */
  insertTuple(tuple: AddTupleRequest): Promise<void>;

  /** Delete a tuple by natural key */
  deleteTuple(tuple: RemoveTupleRequest): Promise<boolean>;

  // === Query ===

  /** List candidate object IDs for list_objects (pre-filter, check still required) */
  listCandidateObjectIds(
    objectType: string,
  ): Promise<string[]>;

  /** List direct subjects for an object + relation */
  listDirectSubjects(
    objectType: string,
    objectId: string,
    relation: string,
  ): Promise<Array<{ subjectType: string; subjectId: string; subjectRelation?: string }>>;

  // === Config management ===

  /** Insert or update a relation config */
  upsertRelationConfig(config: RelationConfig): Promise<void>;

  /** Delete a relation config */
  deleteRelationConfig(objectType: string, relation: string): Promise<boolean>;

  /** Insert or update a condition definition */
  upsertConditionDefinition(condition: ConditionDefinition): Promise<void>;

  /** Delete a condition definition */
  deleteConditionDefinition(name: string): Promise<boolean>;
}
```

## Check Algorithm (`src/core/check.ts`)

This is the most critical file. It must faithfully port the 5-step recursive algorithm from pgfga's `pgfga.check()` function (pgfga/02_check.sql lines 56-200).

```typescript
export async function check(
  store: TupleStore,
  request: CheckRequest,
  options: CheckOptions = {},
  depth: number = 0,
): Promise<boolean> {
  const maxDepth = options.maxDepth ?? 10;

  // Prevent infinite recursion
  if (depth > maxDepth) {
    return false;
  }

  // Step 1: Direct tuple check
  // Look for exact match: (objectType, objectId, relation, subjectType, subjectId)
  // where subject_relation IS NULL.
  // If the tuple has a conditionName, evaluate the CEL condition.
  // Return true only if no condition or condition evaluates to true.
  const directTuple = await store.findDirectTuple(
    request.objectType, request.objectId, request.relation,
    request.subjectType, request.subjectId,
  );
  if (directTuple) {
    if (await evaluateTupleCondition(store, directTuple, request.context)) {
      return true;
    }
  }

  // Step 2: Userset expansion
  // Find tuples where subject_relation IS NOT NULL.
  // e.g., (channel:proj, writer, workspace:sandcastle#member)
  // For each, recursively check if the user has the subject_relation
  // on the referenced subject object.
  // If the userset tuple has a conditionName, evaluate before recursing.
  const usersetTuples = await store.findUsersetTuples(
    request.objectType, request.objectId, request.relation,
  );
  for (const userset of usersetTuples) {
    if (!await evaluateTupleCondition(store, userset, request.context)) {
      continue;
    }
    const hasRelation = await check(store, {
      objectType: userset.subjectType,
      objectId: userset.subjectId,
      relation: userset.subjectRelation!,
      subjectType: request.subjectType,
      subjectId: request.subjectId,
      context: request.context,
    }, options, depth + 1);
    if (hasRelation) {
      return true;
    }
  }

  // Fetch relation config ONCE for steps 3-5
  // (pgfga does 3 separate queries; we optimize to 1)
  const config = await store.findRelationConfig(
    request.objectType, request.relation,
  );

  // Step 3: Relation inheritance (implied_by)
  // e.g., checking "member" and config says implied_by: ["channels_admin"]
  // → recursively check if user has "channels_admin" on the same object
  if (config?.impliedBy) {
    for (const impliedRelation of config.impliedBy) {
      const hasRelation = await check(store, {
        ...request,
        relation: impliedRelation,
      }, options, depth + 1);
      if (hasRelation) {
        return true;
      }
    }
  }

  // Step 4: Computed userset
  // e.g., for branch.can_merge, computed_userset = "can_push" means
  // users who can push can also merge (on the same object)
  if (config?.computedUserset) {
    const hasRelation = await check(store, {
      ...request,
      relation: config.computedUserset,
    }, options, depth + 1);
    if (hasRelation) {
      return true;
    }
  }

  // Step 5: Tuple-to-userset
  // e.g., for repo.read with ttu = {tupleset: "organization", computed_userset: "member"}
  // Find tuples (repo, objectId, "organization", ?, ?) to get the linked org,
  // then check if user has "member" on that org.
  if (config?.tupleToUserset) {
    const { tupleset, computedUserset } = config.tupleToUserset;
    const linkedTuples = await store.findTuplesByRelation(
      request.objectType, request.objectId, tupleset,
    );
    for (const linked of linkedTuples) {
      const hasRelation = await check(store, {
        objectType: linked.subjectType,
        objectId: linked.subjectId,
        relation: computedUserset,
        subjectType: request.subjectType,
        subjectId: request.subjectId,
        context: request.context,
      }, options, depth + 1);
      if (hasRelation) {
        return true;
      }
    }
  }

  return false;
}
```

**Critical implementation notes:**
- Steps 3, 4, 5 all use the SAME `config` fetched once (pgfga does 3 separate
  `SELECT` queries)
- Do NOT merge `impliedBy` and `computedUserset` into one concept; they are
  distinct OpenFGA features
- The `depth` parameter is internal; it is not exposed in the public API
- `maxDepth` defaults to 10 but is configurable via `CheckOptions`

## CEL Conditions (`src/core/conditions.ts`)

Uses `@marcbachmann/cel-js` to evaluate Common Expression Language conditions on
tuples.

```typescript
import { Environment } from "@marcbachmann/cel-js";

/** Cache compiled CEL environments by condition name */
const envCache = new Map<string, Environment>();

/**
 * Evaluate a tuple's condition. Returns true if:
 * - The tuple has no condition (unconditional access)
 * - The condition evaluates to true
 * Returns false if the condition evaluates to false.
 * Throws ConditionNotFoundError if conditionName references a missing definition.
 * Throws ConditionEvaluationError if CEL evaluation fails.
 */
export async function evaluateTupleCondition(
  store: TupleStore,
  tuple: Tuple,
  requestContext?: Record<string, unknown>,
): Promise<boolean> {
  if (!tuple.conditionName) {
    return true; // No condition = unconditional access
  }

  const condDef = await store.findConditionDefinition(tuple.conditionName);
  if (!condDef) {
    throw new ConditionNotFoundError(tuple.conditionName);
  }

  // Merge contexts: request context wins over tuple context
  const context = { ...tuple.conditionContext, ...requestContext };

  let env = envCache.get(condDef.name);
  if (!env) {
    env = new Environment();
    envCache.set(condDef.name, env);
  }

  try {
    const result = env.evaluate(condDef.expression, context);
    return result === true;
  } catch (error) {
    throw new ConditionEvaluationError(condDef.name, error);
  }
}
```

**Context merge rule:** `requestContext` properties override
`tuple.conditionContext` properties. This matches OpenFGA behavior where the
check request context takes precedence.

## Error Types (`src/core/errors.ts`)

```typescript
export class TsfgaError extends Error {
  constructor(message: string) {
    super(message);
    this.name = "TsfgaError";
  }
}

export class RelationConfigNotFoundError extends TsfgaError {
  constructor(objectType: string, relation: string) {
    super(`No relation config found for ${objectType}.${relation}`);
    this.name = "RelationConfigNotFoundError";
  }
}

export class InvalidSubjectTypeError extends TsfgaError {
  constructor(subjectType: string, objectType: string, relation: string, allowed: string[]) {
    super(
      `Subject type '${subjectType}' is not allowed for ${objectType}.${relation}. Allowed: ${allowed.join(", ")}`,
    );
    this.name = "InvalidSubjectTypeError";
  }
}

export class UsersetNotAllowedError extends TsfgaError {
  constructor(objectType: string, relation: string) {
    super(`Userset subjects are not allowed for ${objectType}.${relation}`);
    this.name = "UsersetNotAllowedError";
  }
}

export class ConditionNotFoundError extends TsfgaError {
  constructor(conditionName: string) {
    super(`Condition definition not found: ${conditionName}`);
    this.name = "ConditionNotFoundError";
  }
}

export class ConditionEvaluationError extends TsfgaError {
  cause: unknown;
  constructor(conditionName: string, cause: unknown) {
    super(`Failed to evaluate condition '${conditionName}': ${cause}`);
    this.name = "ConditionEvaluationError";
    this.cause = cause;
  }
}
```

## Kysely Adapter (`src/store/kysely/`)

### Migration (`src/store/kysely/migrations/001-initial.ts`)

Creates the `tsfga` schema with 3 tables and 6 indexes matching pgfga's schema
design.

```sql
-- Schema
CREATE SCHEMA IF NOT EXISTS tsfga;

-- Table: tsfga.tuples
CREATE TABLE tsfga.tuples (
    id bigint GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
    object_type text NOT NULL,
    object_id uuid NOT NULL,
    relation text NOT NULL,
    subject_type text NOT NULL,
    subject_id uuid NOT NULL,
    subject_relation text,
    condition_name text,
    condition_context jsonb,
    metadata jsonb,
    created_at timestamptz DEFAULT now(),
    updated_at timestamptz DEFAULT now()
);

-- Unique index (handles NULL subject_relation)
CREATE UNIQUE INDEX idx_tuples_unique
  ON tsfga.tuples (object_type, object_id, relation, subject_type, subject_id, COALESCE(subject_relation, ''));

-- Table: tsfga.relation_configs
CREATE TABLE tsfga.relation_configs (
    id bigint GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
    object_type text NOT NULL,
    relation text NOT NULL,
    directly_assignable_types text[],
    implied_by text[],
    computed_userset text,
    tuple_to_userset jsonb,
    allows_userset_subjects boolean DEFAULT true,
    metadata jsonb,
    UNIQUE (object_type, relation)
);

-- Table: tsfga.condition_definitions
CREATE TABLE tsfga.condition_definitions (
    id bigint GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
    name text NOT NULL UNIQUE,
    expression text NOT NULL,
    parameters jsonb NOT NULL DEFAULT '{}'
);

-- Indexes (matching pgfga's 6 indexes)
-- 1. Fast lookups by object
CREATE INDEX idx_tuples_object ON tsfga.tuples (object_type, object_id);

-- 2. Fast lookups by subject (reverse queries)
CREATE INDEX idx_tuples_subject ON tsfga.tuples (subject_type, subject_id);

-- 3. Fast relation checks
CREATE INDEX idx_tuples_check ON tsfga.tuples (object_type, object_id, relation, subject_type, subject_id);

-- 4. Fast userset expansion (matches findUsersetTuples query pattern)
-- Note: pgfga indexes (subject_type, subject_id, subject_relation) for reverse lookups.
-- tsfga indexes (object_type, object_id, relation) to match the forward lookup in step 2.
CREATE INDEX idx_tuples_userset ON tsfga.tuples (object_type, object_id, relation)
    WHERE subject_relation IS NOT NULL;

-- 5. JSONB GIN index for metadata queries
CREATE INDEX idx_tuples_metadata ON tsfga.tuples USING GIN (metadata)
    WHERE metadata IS NOT NULL;

-- 6. Condition name lookup
CREATE INDEX idx_tuples_condition ON tsfga.tuples (condition_name)
    WHERE condition_name IS NOT NULL;
```

**Key differences from pgfga:**
- `bigint GENERATED ALWAYS AS IDENTITY` instead of `BIGSERIAL` for PKs
- `object_id` and `subject_id` are `uuid` (pgfga uses `text`)
- Added `condition_name`, `condition_context` columns to `tsfga.tuples`
- Added `tsfga.condition_definitions` table
- Schema is `tsfga` (not `pgfga`)
- Userset index is on `(object_type, object_id, relation) WHERE subject_relation IS NOT NULL`
  to match the `findUsersetTuples` query pattern (pgfga uses
  `(subject_type, subject_id, subject_relation)` for reverse lookups instead)

### Schema Generation (`src/store/kysely/schema.ts`)

This file is **generated by `kysely-codegen`** from the actual database schema
after running migrations. **DO NOT hand-edit this file.** Regenerate with:

```bash
bun run db:generate
```

The generation workflow:
1. Write/modify migrations in `src/store/kysely/migrations/`
2. Start Docker: `docker compose up -d postgres`
3. Run migrations against dev DB
4. Run `kysely-codegen` to regenerate `schema.ts`
5. Commit the generated file (so consumers don't need kysely-codegen)

### Adapter (`src/store/kysely/adapter.ts`)

`KyselyTupleStore` implements `TupleStore`. It receives a `Kysely<DB>` instance
(does NOT own it).

```typescript
export class KyselyTupleStore implements TupleStore {
  constructor(private db: Kysely<DB>) {}
  // ... implements all TupleStore methods
}
```

**UUID mapping:** The DB stores `object_id` and `subject_id` as `uuid`. The
`TupleStore` interface uses `string`. The adapter handles conversion in both
directions. Callers pass UUID-formatted strings
(e.g., `"550e8400-e29b-41d4-a716-446655440000"`).

## Public API (`src/index.ts`)

```typescript
export function createTsfga(store: TupleStore, options?: CheckOptions): TsfgaClient;

export interface TsfgaClient {
  check(request: CheckRequest): Promise<boolean>;
  addTuple(request: AddTupleRequest): Promise<void>;
  removeTuple(request: RemoveTupleRequest): Promise<boolean>;
  listObjects(objectType: string, relation: string, subjectType: string, subjectId: string): Promise<string[]>;
  listSubjects(objectType: string, objectId: string, relation: string): Promise<Array<{ subjectType: string; subjectId: string; subjectRelation?: string }>>;
  writeRelationConfig(config: RelationConfig): Promise<void>;
  deleteRelationConfig(objectType: string, relation: string): Promise<boolean>;
  writeConditionDefinition(condition: ConditionDefinition): Promise<void>;
  deleteConditionDefinition(name: string): Promise<boolean>;
}
```

**Re-exports:** `src/index.ts` also re-exports all types, errors, the `TupleStore`
interface, and `KyselyTupleStore`.

## Conformance Testing

Conformance tests validate that tsfga produces identical results to a real
OpenFGA service. This is the most important testing layer.

### Pattern

Replicated from pgfga's conformance infrastructure (`tests/helpers/conformance.ts`,
`scripts/lib/openfga.ts`, `scripts/lib/infrastructure.ts`).

### Docker Compose (`compose.yaml`)

Runs PostgreSQL + OpenFGA (with migration sidecar), same pattern as pgfga:

```yaml
services:
  postgres:
    image: postgres:18-alpine
    ports:
      - ${POSTGRES_PORT}:5432
    environment:
      POSTGRES_DB: ${POSTGRES_DB}
      POSTGRES_USER: ${POSTGRES_USER}
      POSTGRES_PASSWORD: ${POSTGRES_PASSWORD}
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U $${POSTGRES_USER} -d $${POSTGRES_DB}"]
      interval: 10s
      retries: 5
      start_period: 30s
      timeout: 10s

  openfga-migrate:
    depends_on:
      postgres:
        condition: service_healthy
    image: openfga/openfga:latest
    environment:
      - OPENFGA_DATASTORE_ENGINE=postgres
      - OPENFGA_DATASTORE_URI=postgres://${POSTGRES_USER}:${POSTGRES_PASSWORD}@postgres:5432/${POSTGRES_DB}?sslmode=disable&search_path=openfga
    command: migrate

  openfga:
    depends_on:
      openfga-migrate:
        condition: service_completed_successfully
    image: openfga/openfga:latest
    command: run
    environment:
      - OPENFGA_DATASTORE_ENGINE=postgres
      - OPENFGA_DATASTORE_URI=postgres://${POSTGRES_USER}:${POSTGRES_PASSWORD}@postgres:5432/${POSTGRES_DB}?sslmode=disable&search_path=openfga
      - OPENFGA_PLAYGROUND_ENABLED=true
    ports:
      - "8080:8080"
      - "8081:8081"
      - "3000:3000"
    healthcheck:
      test: ["CMD", "/usr/local/bin/grpc_health_probe", "-addr=openfga:8081"]
      interval: 5s
      timeout: 30s
      retries: 3
```

OpenFGA uses its own `openfga` schema in the same PostgreSQL instance. tsfga
uses the `tsfga` schema. They share the database but not schema.

### Environment (`.env`)

```
POSTGRES_DB=dev
POSTGRES_HOST=localhost
POSTGRES_PASSWORD=password
POSTGRES_PORT=5432
POSTGRES_USER=dev
FGA_API_URL=http://localhost:8080
PREFIX=tsfga
```

### Test Preload (`tests/helpers/preload.ts`)

```typescript
import { setupInfrastructure } from "tests/helpers/infrastructure.ts";
await setupInfrastructure();
```

`setupInfrastructure()` does:
1. `docker compose down` + volume cleanup
2. `docker compose up -d --wait`
3. Wait for PostgreSQL (poll with `SELECT 1`)
4. Wait for OpenFGA (poll `GET /stores`)
5. Run Kysely migrations to create `tsfga` schema

### OpenFGA Helpers (`tests/helpers/openfga.ts`)

Same pattern as pgfga's `scripts/lib/openfga.ts`:

```typescript
import { OpenFgaClient } from "@openfga/sdk";
import { transformer } from "@openfga/syntax-transformer";
import { parse as parseYaml } from "yaml";

export function createClient(storeId?: string): OpenFgaClient;
export async function fgaCreateStore(name: string): Promise<string>;
export async function fgaWriteModel(storeId: string, modelPath: string): Promise<string>;
export async function fgaWriteTuples(storeId: string, tuplesPath: string): Promise<void>;
export async function fgaCheck(storeId: string, params: CheckParams): Promise<boolean | null>;
```

### Conformance Helper (`tests/helpers/conformance.ts`)

```typescript
import { expect } from "bun:test";

/**
 * Assert that tsfga and OpenFGA return the same result for a permission check.
 * Runs both checks in parallel for speed.
 */
export async function expectConformance(
  storeId: string,
  tsfgaClient: TsfgaClient,
  params: CheckRequest,
  expected: boolean,
): Promise<void> {
  const [tsfgaResult, openFgaResult] = await Promise.all([
    tsfgaClient.check(params),
    fgaCheck(storeId, {
      objectType: params.objectType,
      objectId: params.objectId,
      relation: params.relation,
      subjectType: params.subjectType,
      subjectId: params.subjectId,
    }),
  ]);

  if (openFgaResult === null) {
    throw new Error("OpenFGA returned an error");
  }

  // Both systems must agree
  expect(tsfgaResult).toBe(openFgaResult);
  // And match expected value
  expect(tsfgaResult).toBe(expected);
}
```

**Key difference from pgfga:** `expectConformance` receives a `TsfgaClient`
instance (not a raw SQL connection). The tsfga check runs through the library's
own API.

### Conformance Test File (`tests/conformance/slack.test.ts`)

```typescript
import { afterAll, beforeAll, describe, test } from "bun:test";
import { createTsfga, KyselyTupleStore } from "src/index.ts";
import { expectConformance } from "tests/helpers/conformance.ts";
import { fgaCreateStore, fgaWriteModel, fgaWriteTuples } from "tests/helpers/openfga.ts";

describe("Slack Model Conformance", () => {
  let storeId: string;
  let tsfgaClient: TsfgaClient;

  beforeAll(async () => {
    // Setup tsfga: create KyselyTupleStore, load relation configs + tuples
    const store = new KyselyTupleStore(db);
    tsfgaClient = createTsfga(store);

    // Write relation configs matching the Slack model
    // Write tuples matching examples/slack/tuples.yaml

    // Setup OpenFGA
    storeId = await fgaCreateStore("slack-test");
    await fgaWriteModel(storeId, "examples/slack/model.dsl");
    await fgaWriteTuples(storeId, "examples/slack/tuples.yaml");
  });

  // ... 28 check assertions using expectConformance()
});
```

**Reuse from pgfga:** The `model.dsl` and `tuples.yaml` files are copied from
pgfga's `examples/slack/` directory. The relation configs and tuples are loaded
via tsfga's own API (`tsfgaClient.writeRelationConfig()`, `tsfgaClient.addTuple()`).

### Test Scope

- **Slack model**: 28 checks (workspace + channel relations, userset expansion)
- **GitHub model**: 50+ checks (organization, team, repo relations, tuple-to-userset)

## Dependencies

### Runtime
- `@marcbachmann/cel-js` - CEL expression evaluation

### Peer
- `kysely` >= 0.27.0 - Query builder
- `pg` >= 8.0.0 - PostgreSQL driver

### Dev
- `@biomejs/biome` - Linter + formatter
- `@types/bun` - Bun type definitions
- `typescript` - Type checking
- `kysely-codegen` - Generate Kysely types from DB schema
- `@openfga/sdk` - OpenFGA client for conformance tests
- `@openfga/syntax-transformer` - DSL to JSON for conformance tests
- `yaml` - Parse tuples.yaml files

## Dev Commands

```bash
bun install                              # Install dependencies
bun run test                             # All tests (needs Docker)
bun test tests/core/                     # Unit tests only (no Docker)
bun test tests/conformance/              # Conformance tests (needs Docker)
bun test tests/store/                    # Integration tests (needs Docker)
bun run tsc                              # Type check
bun run check                            # Lint + format check
bun run lint                             # Lint only
bun run format                           # Format fix
bun run db:generate                      # Regenerate Kysely types from DB
```

### Type Generation Workflow

```bash
# 1. Modify migrations
#    Edit src/store/kysely/migrations/001-initial.ts

# 2. Start PostgreSQL
docker compose up -d postgres

# 3. Run migrations (via a script or test setup)

# 4. Regenerate types
bun run db:generate
# This runs: bunx kysely-codegen --out-file src/store/kysely/schema.ts

# 5. Commit the generated schema.ts
```

## Configuration Files

### `bunfig.toml`

```toml
[install]
exact = true

[test]
timeout = 120000
preload = ["./tests/helpers/preload.ts"]
```

### `tsconfig.json`

```json
{
  "compilerOptions": {
    "lib": ["ESNext"],
    "target": "ESNext",
    "module": "Preserve",
    "moduleDetection": "force",
    "allowJs": true,
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "verbatimModuleSyntax": true,
    "noEmit": true,
    "strict": true,
    "skipLibCheck": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedIndexedAccess": true,
    "noImplicitOverride": true,
    "noUnusedLocals": false,
    "noUnusedParameters": false,
    "noPropertyAccessFromIndexSignature": false,
    "paths": {
      "src/*": ["./src/*"],
      "tests/*": ["./tests/*"]
    }
  }
}
```

### `biome.json`

```json
{
  "$schema": "https://biomejs.dev/schemas/2.3.13/schema.json",
  "vcs": {
    "enabled": true,
    "clientKind": "git",
    "useIgnoreFile": true
  },
  "files": {
    "ignoreUnknown": false,
    "includes": ["**/*.ts"],
    "ignore": ["src/store/kysely/schema.ts"]
  },
  "formatter": {
    "enabled": true,
    "indentStyle": "space",
    "indentWidth": 2
  },
  "linter": {
    "enabled": true,
    "rules": {
      "recommended": true,
      "complexity": {
        "useLiteralKeys": "off"
      },
      "style": {
        "noRestrictedImports": {
          "level": "error",
          "options": {
            "paths": {
              "pg": {
                "message": "Do not import pg directly in core/. Use the TupleStore interface."
              }
            }
          }
        },
        "useFilenamingConvention": {
          "level": "error",
          "options": {
            "filenameCases": ["kebab-case"]
          }
        }
      }
    }
  },
  "javascript": {
    "formatter": {
      "quoteStyle": "double"
    }
  },
  "assist": {
    "enabled": true,
    "actions": {
      "source": {
        "organizeImports": {
          "level": "on",
          "options": {
            "groups": [
              ":BUN:",
              ":NODE:",
              ":PACKAGE:",
              ":PACKAGE_WITH_PROTOCOL:",
              ":URL:",
              ":ALIAS:",
              ":PATH:"
            ]
          }
        }
      }
    }
  }
}
```

## Git Commit Messages

- **Never** use conventional commit format (`feat:`, `fix:`, `chore:`, etc.)
- Header is a single line of **at most 50 characters**, in imperative
  mood, starting with a capital letter, that meaningfully summarizes
  the change (shown by `gitk`, `git shortlog`)
- Body explains the *why* -- motivation, background, reasoning for the
  chosen approach -- not just *what* changed (the diff shows that)
- Wrap body paragraphs at ~74 columns
- Use imperative verbs: "Fix ...", "Add ...", "Make ...",
  "Refactor ...", "Remove ..."

## Anti-Patterns (DO NOT)

- **No session context coupling.** pgfga uses `set_config`/`current_setting`
  for RLS. tsfga always receives `subjectType` and `subjectId` explicitly in
  every check call. There is no global user context.
- **No SECURITY DEFINER.** This is a PostgreSQL-specific mechanism for RLS
  bypass. Not applicable to a TypeScript library.
- **Single config fetch for steps 3-5.** pgfga does 3 separate `SELECT` queries
  from `relation_configs` (one each for implied_by, computed_userset,
  tuple_to_userset). tsfga fetches the config once and reads all three fields
  from the result.
- **Don't merge implied_by and computed_userset.** They are distinct OpenFGA
  concepts. `implied_by` means "relation X on the same object type implies this
  relation" (e.g., `channels_admin` implies `member`). `computed_userset` means
  "check a different relation on the same object" (used in GitHub model for
  `can_merge` -> `can_push`).
- **Don't skip condition evaluation on userset tuples.** Both direct tuples
  (step 1) and userset tuples (step 2) can have conditions. Evaluate before
  accepting or recursing.
- **Don't use Kysely types in core/.** The core module must remain
  database-agnostic.

## References

- pgfga source: `~/repositories/lemuelroberto/poc-pgfga/`
- OpenFGA docs: https://openfga.dev/docs/modeling/getting-started
- OpenFGA conditions: https://openfga.dev/docs/modeling/conditions
- CEL spec: https://github.com/google/cel-spec
- `@marcbachmann/cel-js`: https://github.com/nicholasgasior/cel-js
- Kysely docs: https://kysely.dev/
- kysely-codegen: https://github.com/RobinBlomberg/kysely-codegen
