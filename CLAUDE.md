# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with
code in this repository.

## Project Overview

**tsfga** is a TypeScript monorepo that implements OpenFGA-compatible
relationship-based access control (ReBAC). It provides a 5-step recursive
check algorithm, CEL condition support, and a database-agnostic architecture
with a Kysely adapter for PostgreSQL.

### Packages

| Package | Path | Published | Description |
|---------|------|-----------|-------------|
| `@tsfga/core` | `packages/core` | Yes | Check algorithm, conditions, types, TupleStore interface |
| `@tsfga/kysely` | `packages/kysely` | Yes | KyselyTupleStore adapter, migrations, schema |
| `@tsfga/conformance` | `tests/conformance` | No (private) | OpenFGA conformance tests |

### Scope

**In scope:**
- Core check algorithm (5-step recursive)
- CRUD operations for tuples, relation configs, and condition definitions
- CEL condition evaluation via `@marcbachmann/cel-js`
- Kysely adapter for PostgreSQL
- Conformance testing against real OpenFGA

**Out of scope:**
- DSL parsing (use `@openfga/syntax-transformer` in tests)
- HTTP server / API layer
- Multi-tenant store isolation
- Watch / streaming APIs

## Architecture

```
createTsfga (public API)          — @tsfga/core
  ↓
check / conditions (core algorithm) — @tsfga/core
  ↓
TupleStore (interface)             — @tsfga/core
  ↓
KyselyTupleStore (adapter)        — @tsfga/kysely
```

**Key rule:** `@tsfga/core` never imports from `@tsfga/kysely`. The core
algorithm depends only on the `TupleStore` interface.

## Directory Structure

```
tsfga/
├── packages/
│   ├── core/                        @tsfga/core
│   │   ├── src/
│   │   │   ├── index.ts             barrel: createTsfga() + re-exports
│   │   │   ├── check.ts             5-step recursive check algorithm
│   │   │   ├── conditions.ts        CEL condition evaluation
│   │   │   ├── contextual-store.ts  ContextualTupleStore wrapper
│   │   │   ├── types.ts             All shared types
│   │   │   ├── errors.ts            Error hierarchy
│   │   │   └── store-interface.ts   TupleStore interface definition
│   │   ├── tests/
│   │   │   ├── check.test.ts
│   │   │   ├── conditions.test.ts
│   │   │   └── helpers/
│   │   │       └── mock-store.ts
│   │   ├── package.json
│   │   ├── tsconfig.json
│   │   └── tsup.config.ts
│   │
│   └── kysely/                      @tsfga/kysely
│       ├── src/
│       │   ├── index.ts             exports KyselyTupleStore, DB
│       │   ├── adapter.ts           KyselyTupleStore implements TupleStore
│       │   ├── schema.ts            Generated by kysely-codegen (DO NOT EDIT)
│       │   └── migrations/
│       │       ├── 001-initial.ts
│       │       └── 002-add-operators.ts
│       ├── tests/
│       │   ├── kysely-adapter.test.ts
│       │   └── helpers/
│       │       ├── db.ts
│       │       ├── infrastructure.ts  PG-only health check
│       │       └── preload.ts
│       ├── package.json
│       ├── tsconfig.json
│       ├── tsup.config.ts
│       ├── bunfig.toml
│       ├── kysely.config.ts
│       └── .kysely-codegenrc.json
│
├── tests/
│   └── conformance/                 @tsfga/conformance (private)
│       ├── helpers/
│       │   ├── conformance.ts       expectConformance() helper
│       │   ├── db.ts                Transaction management
│       │   ├── infrastructure.ts    PG + OpenFGA health check
│       │   ├── openfga.ts           OpenFGA SDK client operations
│       │   └── preload.ts           Infrastructure setup
│       ├── slack.test.ts
│       ├── slack/ (model.dsl, tuples.yaml)
│       ├── ... (all conformance tests + fixtures)
│       ├── theopenlane/ (setup.ts, model.dsl, tuples.yaml)
│       ├── package.json
│       ├── tsconfig.json
│       └── bunfig.toml
│
├── package.json                     root workspace config
├── turbo.json                       Turborepo pipeline
├── tsconfig.base.json               shared TS compiler options
├── tsconfig.json                    references-only (whole-repo tsc)
├── biome.json                       shared lint/format
├── compose.yaml                     PostgreSQL + OpenFGA services
├── .env                             environment variables
├── .changeset/                      versioning config
└── CLAUDE.md
```

## Core Types (`packages/core/src/types.ts`)

```typescript
/** A relationship tuple with optional condition */
export interface Tuple {
  objectType: string;
  objectId: string;
  relation: string;
  subjectType: string;
  subjectId: string;
  subjectRelation?: string;
  conditionName?: string;
  conditionContext?: Record<string, unknown>;
}

/** Configuration for a relation on an object type */
export interface RelationConfig {
  objectType: string;
  relation: string;
  directlyAssignableTypes?: string[];
  impliedBy?: string[];
  computedUserset?: string;
  tupleToUserset?: Array<{ tupleset: string; computedUserset: string }>;
  excludedBy?: string;
  intersection?: IntersectionOperand[];
  allowsUsersetSubjects: boolean;
}

/** Operand for intersection-based relations */
export interface IntersectionOperand {
  type: "direct" | "computedUserset" | "tupleToUserset";
  relation?: string;
  tupleset?: string;
  computedUserset?: string;
}

/** A named CEL condition definition */
export interface ConditionDefinition {
  name: string;
  expression: string;
  parameters: Record<string, ConditionParameterType>;
}

/** Supported CEL parameter types */
export type ConditionParameterType =
  | "string"
  | "int"
  | "uint"
  | "bool"
  | "double"
  | "duration"
  | "timestamp"
  | "list"
  | "map"
  | "any";

/** Parameters for a check request */
export interface CheckRequest {
  objectType: string;
  objectId: string;
  relation: string;
  subjectType: string;
  subjectId: string;
  context?: Record<string, unknown>;
}

/** Options for the check algorithm */
export interface CheckOptions {
  /** Maximum recursion depth (default: 10) */
  maxDepth?: number;
}

/** Parameters for adding a tuple */
export interface AddTupleRequest {
  objectType: string;
  objectId: string;
  relation: string;
  subjectType: string;
  subjectId: string;
  subjectRelation?: string;
  conditionName?: string;
  conditionContext?: Record<string, unknown>;
}

/** Parameters for removing a tuple */
export interface RemoveTupleRequest {
  objectType: string;
  objectId: string;
  relation: string;
  subjectType: string;
  subjectId: string;
  subjectRelation?: string;
}
```

## TupleStore Interface (`packages/core/src/store-interface.ts`)

The `TupleStore` is the abstraction boundary between the core algorithm and any
database backend. All methods return `Promise`.

```typescript
export interface TupleStore {
  // === Read ===

  /** Check if a direct tuple exists (no subject_relation) */
  findDirectTuple(
    objectType: string,
    objectId: string,
    relation: string,
    subjectType: string,
    subjectId: string,
  ): Promise<Tuple | null>;

  /** Find tuples where subject_relation IS NOT NULL (userset expansion) */
  findUsersetTuples(
    objectType: string,
    objectId: string,
    relation: string,
  ): Promise<Tuple[]>;

  /** Find tuples by object + relation (for tuple-to-userset tupleset lookup) */
  findTuplesByRelation(
    objectType: string,
    objectId: string,
    relation: string,
  ): Promise<Tuple[]>;

  /** Get relation config for an object_type + relation */
  findRelationConfig(
    objectType: string,
    relation: string,
  ): Promise<RelationConfig | null>;

  /** Get a condition definition by name */
  findConditionDefinition(name: string): Promise<ConditionDefinition | null>;

  // === Write ===

  /** Insert or update a tuple (upsert on natural key) */
  insertTuple(tuple: AddTupleRequest): Promise<void>;

  /** Delete a tuple by natural key */
  deleteTuple(tuple: RemoveTupleRequest): Promise<boolean>;

  // === Query ===

  /** List candidate object IDs for list_objects (pre-filter, check still required) */
  listCandidateObjectIds(
    objectType: string,
  ): Promise<string[]>;

  /** List direct subjects for an object + relation */
  listDirectSubjects(
    objectType: string,
    objectId: string,
    relation: string,
  ): Promise<Array<{ subjectType: string; subjectId: string; subjectRelation?: string }>>;

  // === Config management ===

  /** Insert or update a relation config */
  upsertRelationConfig(config: RelationConfig): Promise<void>;

  /** Delete a relation config */
  deleteRelationConfig(objectType: string, relation: string): Promise<boolean>;

  /** Insert or update a condition definition */
  upsertConditionDefinition(condition: ConditionDefinition): Promise<void>;

  /** Delete a condition definition */
  deleteConditionDefinition(name: string): Promise<boolean>;
}
```

## Check Algorithm (`packages/core/src/check.ts`)

This is the most critical file. It implements the 5-step recursive
check algorithm for relationship-based access control.

```typescript
export async function check(
  store: TupleStore,
  request: CheckRequest,
  options: CheckOptions = {},
  depth: number = 0,
): Promise<boolean> {
  const maxDepth = options.maxDepth ?? 10;

  // Prevent infinite recursion
  if (depth > maxDepth) {
    return false;
  }

  // Step 1: Direct tuple check
  // Look for exact match: (objectType, objectId, relation, subjectType, subjectId)
  // where subject_relation IS NULL.
  // If the tuple has a conditionName, evaluate the CEL condition.
  // Return true only if no condition or condition evaluates to true.
  const directTuple = await store.findDirectTuple(
    request.objectType, request.objectId, request.relation,
    request.subjectType, request.subjectId,
  );
  if (directTuple) {
    if (await evaluateTupleCondition(store, directTuple, request.context)) {
      return true;
    }
  }

  // Step 2: Userset expansion
  // Find tuples where subject_relation IS NOT NULL.
  // e.g., (channel:proj, writer, workspace:sandcastle#member)
  // For each, recursively check if the user has the subject_relation
  // on the referenced subject object.
  // If the userset tuple has a conditionName, evaluate before recursing.
  const usersetTuples = await store.findUsersetTuples(
    request.objectType, request.objectId, request.relation,
  );
  for (const userset of usersetTuples) {
    if (!await evaluateTupleCondition(store, userset, request.context)) {
      continue;
    }
    const hasRelation = await check(store, {
      objectType: userset.subjectType,
      objectId: userset.subjectId,
      relation: userset.subjectRelation!,
      subjectType: request.subjectType,
      subjectId: request.subjectId,
      context: request.context,
    }, options, depth + 1);
    if (hasRelation) {
      return true;
    }
  }

  // Fetch once for steps 3-5
  const config = await store.findRelationConfig(
    request.objectType, request.relation,
  );

  // Step 3: Relation inheritance (implied_by)
  // e.g., checking "member" and config says implied_by: ["channels_admin"]
  // → recursively check if user has "channels_admin" on the same object
  if (config?.impliedBy) {
    for (const impliedRelation of config.impliedBy) {
      const hasRelation = await check(store, {
        ...request,
        relation: impliedRelation,
      }, options, depth + 1);
      if (hasRelation) {
        return true;
      }
    }
  }

  // Step 4: Computed userset
  // e.g., for branch.can_merge, computed_userset = "can_push" means
  // users who can push can also merge (on the same object)
  if (config?.computedUserset) {
    const hasRelation = await check(store, {
      ...request,
      relation: config.computedUserset,
    }, options, depth + 1);
    if (hasRelation) {
      return true;
    }
  }

  // Step 5: Tuple-to-userset (array — supports multiple TTU paths per relation)
  // e.g., for project.editor with tupleToUserset:
  //   [{ tupleset: "owner", computedUserset: "project_editor" },
  //    { tupleset: "partner", computedUserset: "project_editor" }]
  // For each TTU entry, find tuples via tupleset, then check computedUserset
  // on the linked object.
  if (config?.tupleToUserset) {
    for (const { tupleset, computedUserset } of config.tupleToUserset) {
      const linkedTuples = await store.findTuplesByRelation(
        request.objectType, request.objectId, tupleset,
      );
      for (const linked of linkedTuples) {
        const hasRelation = await check(store, {
          objectType: linked.subjectType,
          objectId: linked.subjectId,
          relation: computedUserset,
          subjectType: request.subjectType,
          subjectId: request.subjectId,
          context: request.context,
        }, options, depth + 1);
        if (hasRelation) {
          return true;
        }
      }
    }
  }

  return false;
}
```

**Critical implementation notes:**
- Steps 3, 4, 5 all use the SAME `config` fetched once
- Do NOT merge `impliedBy` and `computedUserset` into one concept; they are
  distinct OpenFGA features
- The `depth` parameter is internal; it is not exposed in the public API
- `maxDepth` defaults to 10 but is configurable via `CheckOptions`

## CEL Conditions (`packages/core/src/conditions.ts`)

Uses `@marcbachmann/cel-js` to evaluate Common Expression Language conditions on
tuples.

```typescript
import { Environment } from "@marcbachmann/cel-js";

/** Cache compiled CEL environments by condition name */
const envCache = new Map<string, Environment>();

/**
 * Evaluate a tuple's condition. Returns true if:
 * - The tuple has no condition (unconditional access)
 * - The condition evaluates to true
 * Returns false if the condition evaluates to false.
 * Throws ConditionNotFoundError if conditionName references a missing definition.
 * Throws ConditionEvaluationError if CEL evaluation fails.
 */
export async function evaluateTupleCondition(
  store: TupleStore,
  tuple: Tuple,
  requestContext?: Record<string, unknown>,
): Promise<boolean> {
  if (!tuple.conditionName) {
    return true; // No condition = unconditional access
  }

  const condDef = await store.findConditionDefinition(tuple.conditionName);
  if (!condDef) {
    throw new ConditionNotFoundError(tuple.conditionName);
  }

  // Merge contexts: request context wins over tuple context
  const context = { ...tuple.conditionContext, ...requestContext };

  let env = envCache.get(condDef.name);
  if (!env) {
    env = new Environment();
    envCache.set(condDef.name, env);
  }

  try {
    const result = env.evaluate(condDef.expression, context);
    return result === true;
  } catch (error) {
    throw new ConditionEvaluationError(condDef.name, error);
  }
}
```

**Context merge rule:** `tuple.conditionContext` properties override
`requestContext` properties. This matches OpenFGA behavior where context
values written in the relationship tuple take precedence.

## Error Types (`packages/core/src/errors.ts`)

```typescript
export class TsfgaError extends Error {
  constructor(message: string) {
    super(message);
    this.name = "TsfgaError";
  }
}

export class RelationConfigNotFoundError extends TsfgaError {
  constructor(objectType: string, relation: string) {
    super(`No relation config found for ${objectType}.${relation}`);
    this.name = "RelationConfigNotFoundError";
  }
}

export class InvalidSubjectTypeError extends TsfgaError {
  constructor(subjectType: string, objectType: string, relation: string, allowed: string[]) {
    super(
      `Subject type '${subjectType}' is not allowed for ${objectType}.${relation}. Allowed: ${allowed.join(", ")}`,
    );
    this.name = "InvalidSubjectTypeError";
  }
}

export class UsersetNotAllowedError extends TsfgaError {
  constructor(objectType: string, relation: string) {
    super(`Userset subjects are not allowed for ${objectType}.${relation}`);
    this.name = "UsersetNotAllowedError";
  }
}

export class ConditionNotFoundError extends TsfgaError {
  constructor(conditionName: string) {
    super(`Condition definition not found: ${conditionName}`);
    this.name = "ConditionNotFoundError";
  }
}

export class ConditionEvaluationError extends TsfgaError {
  cause: unknown;
  constructor(conditionName: string, cause: unknown) {
    super(`Failed to evaluate condition '${conditionName}': ${cause}`);
    this.name = "ConditionEvaluationError";
    this.cause = cause;
  }
}
```

## Kysely Adapter (`packages/kysely/src/`)

### Migration (`packages/kysely/src/migrations/001-initial.ts`)

Creates the `tsfga` schema with 3 tables and 6 indexes. Uses Kysely's DDL
schema builder API where possible; raw `sql` only for indexes the builder
cannot express.

**Pattern:** Prefer `db.schema.createTable()` / `db.schema.createIndex()` over
raw SQL. Use `sql` template literals only when the builder API cannot express
the DDL (expression indexes, GIN + WHERE combos).

**What stays as raw SQL:**
- `idx_tuples_unique` — uses `COALESCE(subject_relation, '')` expression
- `idx_tuples_metadata` — uses `USING GIN` with a `WHERE` clause

**Migration management** uses `kysely-ctl` with config in
`packages/kysely/kysely.config.ts`:
- `bun run db:latest` — apply all pending migrations
- `bun run db:rollback` — rollback all migrations

**Schema produced:**

```sql
-- tsfga.tuples: relationship tuples with optional conditions
-- tsfga.relation_configs: relation definitions (implied_by, computed_userset, etc.)
-- tsfga.condition_definitions: named CEL condition expressions
-- 6 indexes on tsfga.tuples (unique, object, subject, check, userset, metadata, condition)
```

### Schema Generation (`packages/kysely/src/schema.ts`)

This file is **generated by `kysely-codegen`** from the actual database schema
after running migrations. **DO NOT hand-edit this file.** Regenerate with:

```bash
bun run db:generate
```

The generation workflow:
1. Write/modify migrations in `packages/kysely/src/migrations/`
2. Start Docker: `bun run infra:up`
3. Run migrations against dev DB
4. Run `kysely-codegen` to regenerate `schema.ts`
5. Commit the generated file (so consumers don't need kysely-codegen)

### Adapter (`packages/kysely/src/adapter.ts`)

`KyselyTupleStore` implements `TupleStore`. It receives a `Kysely<DB>` instance
(does NOT own it).

```typescript
export class KyselyTupleStore implements TupleStore {
  constructor(private db: Kysely<DB>) {}
  // ... implements all TupleStore methods
}
```

**UUID mapping:** The DB stores `object_id` and `subject_id` as `uuid`. The
`TupleStore` interface uses `string`. The adapter handles conversion in both
directions. Callers pass UUID-formatted strings
(e.g., `"550e8400-e29b-41d4-a716-446655440000"`).

**DML pattern:** Always use Kysely's type-safe query builder for adapter
methods. Use `onConflict().expression(sql`...`)` (without outer parens) for
upserts against expression indexes. Do not use raw `sql` template literals for
INSERT, SELECT, UPDATE, or DELETE queries.

## Public API (`packages/core/src/index.ts`)

```typescript
export function createTsfga(store: TupleStore, options?: CheckOptions): TsfgaClient;

export interface TsfgaClient {
  check(request: CheckRequest): Promise<boolean>;
  addTuple(request: AddTupleRequest): Promise<void>;
  removeTuple(request: RemoveTupleRequest): Promise<boolean>;
  listObjects(objectType: string, relation: string, subjectType: string, subjectId: string): Promise<string[]>;
  listSubjects(objectType: string, objectId: string, relation: string): Promise<Array<{ subjectType: string; subjectId: string; subjectRelation?: string }>>;
  writeRelationConfig(config: RelationConfig): Promise<void>;
  deleteRelationConfig(objectType: string, relation: string): Promise<boolean>;
  writeConditionDefinition(condition: ConditionDefinition): Promise<void>;
  deleteConditionDefinition(name: string): Promise<boolean>;
}
```

**Re-exports:** `packages/core/src/index.ts` re-exports all types, errors,
the `TupleStore` interface, `check`, `evaluateTupleCondition`, and
`ContextualTupleStore`. `KyselyTupleStore` is exported from `@tsfga/kysely`.

## Conformance Testing

Conformance tests validate that tsfga produces identical results to a real
OpenFGA service. This is the most important testing layer.

### Docker Compose (`compose.yaml`)

Runs PostgreSQL + OpenFGA (with migration sidecar):

```yaml
services:
  postgres:
    image: postgres:18-alpine
    ports:
      - ${POSTGRES_PORT}:5432
    environment:
      POSTGRES_DB: ${POSTGRES_DB}
      POSTGRES_USER: ${POSTGRES_USER}
      POSTGRES_PASSWORD: ${POSTGRES_PASSWORD}
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U $${POSTGRES_USER} -d $${POSTGRES_DB}"]
      interval: 10s
      retries: 5
      start_period: 30s
      timeout: 10s

  openfga-migrate:
    depends_on:
      postgres:
        condition: service_healthy
    image: openfga/openfga:latest
    environment:
      - OPENFGA_DATASTORE_ENGINE=postgres
      - OPENFGA_DATASTORE_URI=postgres://${POSTGRES_USER}:${POSTGRES_PASSWORD}@postgres:5432/${POSTGRES_DB}?sslmode=disable&search_path=openfga
    command: migrate

  openfga:
    depends_on:
      openfga-migrate:
        condition: service_completed_successfully
    image: openfga/openfga:latest
    command: run
    environment:
      - OPENFGA_DATASTORE_ENGINE=postgres
      - OPENFGA_DATASTORE_URI=postgres://${POSTGRES_USER}:${POSTGRES_PASSWORD}@postgres:5432/${POSTGRES_DB}?sslmode=disable&search_path=openfga
      - OPENFGA_PLAYGROUND_ENABLED=true
    ports:
      - "8080:8080"
      - "8081:8081"
      - "3000:3000"
    healthcheck:
      test: ["CMD", "/usr/local/bin/grpc_health_probe", "-addr=openfga:8081"]
      interval: 5s
      timeout: 30s
      retries: 3
```

OpenFGA uses its own `openfga` schema in the same PostgreSQL instance. tsfga
uses the `tsfga` schema. They share the database but not schema.

### Environment (`.env`)

```
POSTGRES_DB=dev
POSTGRES_HOST=localhost
POSTGRES_PASSWORD=password
POSTGRES_PORT=5432
POSTGRES_USER=dev
FGA_API_URL=http://localhost:8080
PREFIX=tsfga
```

All configuration comes from environment variables (loaded from `.env` by Bun).
**Never hard-code default values** in `process.env` reads — use bare
`process.env.VAR_NAME`, not `process.env.VAR_NAME || "fallback"`. Defaults
belong in `.env` only, so there is a single source of truth.

### Infrastructure Checks

**`@tsfga/kysely` tests** (`packages/kysely/tests/helpers/infrastructure.ts`):
Only checks PostgreSQL availability.

**`@tsfga/conformance` tests** (`tests/conformance/helpers/infrastructure.ts`):
Checks both PostgreSQL and OpenFGA availability.

Both poll services with retries and fail with actionable errors if not
reachable. Infrastructure must be started before running tests:
```bash
bun run infra:setup    # First time: starts services + runs migrations
bun run infra:up       # Subsequent runs: starts services only
```

### OpenFGA Helpers (`tests/conformance/helpers/openfga.ts`)

```typescript
import { OpenFgaClient } from "@openfga/sdk";
import { transformer } from "@openfga/syntax-transformer";
import { parse as parseYaml } from "yaml";

export function createClient(storeId?: string): OpenFgaClient;
export async function fgaCreateStore(name: string): Promise<string>;
export async function fgaWriteModel(storeId: string, modelPath: string): Promise<string>;
export async function fgaWriteTuples(storeId: string, tuplesPath: string): Promise<void>;
export async function fgaCheck(storeId: string, params: CheckParams): Promise<boolean | null>;
```

### Conformance Helper (`tests/conformance/helpers/conformance.ts`)

```typescript
import { expect } from "bun:test";

/**
 * Assert that tsfga and OpenFGA return the same result for a permission check.
 * Runs both checks in parallel for speed.
 */
export async function expectConformance(
  storeId: string,
  authorizationModelId: string,
  tsfgaClient: TsfgaClient,
  params: CheckRequest,
  expected: boolean,
): Promise<void> {
  const [tsfgaResult, openFgaResult] = await Promise.all([
    tsfgaClient.check(params),
    fgaCheck(storeId, {
      objectType: params.objectType,
      objectId: params.objectId,
      relation: params.relation,
      subjectType: params.subjectType,
      subjectId: params.subjectId,
    }),
  ]);

  if (openFgaResult === null) {
    throw new Error("OpenFGA returned an error");
  }

  // Both systems must agree
  expect(tsfgaResult).toBe(openFgaResult);
  // And match expected value
  expect(tsfgaResult).toBe(expected);
}
```

### Conformance Test Pattern

```typescript
import { afterAll, beforeAll, describe, test } from "bun:test";
import { createTsfga, type TsfgaClient } from "@tsfga/core";
import { KyselyTupleStore } from "@tsfga/kysely";
import { expectConformance } from "./helpers/conformance.ts";

describe("Model Conformance", () => {
  let storeId: string;
  let authorizationModelId: string;
  let tsfgaClient: TsfgaClient;

  beforeAll(async () => {
    // Setup tsfga + OpenFGA, write configs + tuples
  });

  test("user can_view resource", async () => {
    await expectConformance(storeId, authorizationModelId, tsfgaClient, {
      objectType: "resource",
      objectId: uuid("res1"),
      relation: "can_view",
      subjectType: "user",
      subjectId: uuid("alice"),
    }, true);
  });
});
```

## Dependencies

### @tsfga/core
- **Runtime:** `@marcbachmann/cel-js`
- **Dev:** `@types/bun`, `tsup`, `typescript`

### @tsfga/kysely
- **Peer:** `@tsfga/core`, `kysely >=0.27.0`, `pg >=8.0.0`
- **Dev:** `@tsfga/core`, `kysely`, `pg`, `kysely-codegen`, `kysely-ctl`,
  `tsup`, `typescript`

### @tsfga/conformance
- **Dev:** `@tsfga/core`, `@tsfga/kysely`, `@openfga/sdk`,
  `@openfga/syntax-transformer`, `kysely`, `pg`, `yaml`

### Root
- **Dev:** `@biomejs/biome`, `@changesets/cli`, `turbo`, `tsup`, `typescript`

## Dev Commands

**Important:** Bun hijacks `bun run test` to `bun test` (built-in runner),
so turbo-delegated scripts use the `turbo:` prefix. Use `bun run turbo:*`
for turbo tasks.

```bash
# Workspace management
bun install                              # Install all workspace dependencies

# Build & type check (via turbo)
bun run turbo:build                      # Build all packages
bun run turbo:tsc                        # Type check all packages

# Test (via turbo)
bun run turbo:test                       # All tests (infra required)
bun run turbo:test:core                  # Core unit tests (no infra)
bun run turbo:test:kysely                # Adapter tests (PostgreSQL required)
bun run turbo:test:conformance           # Conformance tests (PG + OpenFGA)

# Infrastructure
bun run infra:setup                      # Start services + run migrations
bun run infra:up                         # Start Docker services only
bun run infra:down                       # Tear down services + volumes

# Database
bun run db:latest                        # Apply pending migrations
bun run db:rollback                      # Rollback all migrations
bun run db:generate                      # Regenerate Kysely types from DB

# Code quality
bun run biome:check                      # Lint + format check
bun run biome:lint                       # Lint only
bun run biome:format                     # Format fix

# Versioning
bun run changeset                        # Create a changeset
bun run version                          # Apply changesets to versions
bun run release                          # Build + publish
```

### Type Generation Workflow

```bash
# 1. Modify migrations
#    Edit packages/kysely/src/migrations/

# 2. Start PostgreSQL
bun run infra:up

# 3. Run migrations
bun run db:latest

# 4. Regenerate types
bun run db:generate
# Runs: bunx kysely-codegen --out-file packages/kysely/src/schema.ts

# 5. Commit the generated schema.ts
```

## Configuration Files

### `turbo.json`

Turborepo task pipeline. `build` depends on `^build` (dependency chain).
`test` is never cached. `db:*` tasks are never cached.

### `tsconfig.base.json`

Shared compiler options for all packages. Has `noEmit: true` (type
checking only). No `composite`, `declaration`, or `declarationMap` — those
live in per-package `tsconfig.build.json` files for tsup DTS generation.
No path aliases — packages use relative imports internally and
`@tsfga/core`/`@tsfga/kysely` across packages.

### `tsconfig.json` (root)

Extends `tsconfig.base.json` and includes all source/test files across
the three workspaces. Used for whole-repo type checking (not `tsc --build`
or project references — turbo handles dependency ordering).

### `biome.json`

Shared lint/format config at root. Ignores `**/schema.ts` (generated) and
`**/dist/**` (build output). Uses kebab-case filename convention.

## Git Commit Messages

- **Never** use conventional commit format (`feat:`, `fix:`, `chore:`, etc.)
- Header is a single line of **at most 50 characters**, in imperative
  mood, starting with a capital letter, that meaningfully summarizes
  the change (shown by `gitk`, `git shortlog`)
- Body explains the *why* -- motivation, background, reasoning for the
  chosen approach -- not just *what* changed (the diff shows that)
- Wrap body paragraphs at ~74 columns
- Use imperative verbs: "Fix ...", "Add ...", "Make ...",
  "Refactor ...", "Remove ..."
- When the change is based on or derived from an important external
  source (documentation page, upstream schema, specification, GitHub
  issue/PR), add `Ref:` lines after the body. Use **permalink URLs**
  (pinned to a commit SHA) for GitHub file links so they survive
  future renames. Only reference sources that meaningfully informed
  the implementation — not every tangential link. Multiple sources
  use separate `Ref:` lines or a `Refs:` block.

## Anti-Patterns (DO NOT)

- **No session context coupling.** Always receive `subjectType` and
  `subjectId` explicitly in every check call. There is no global user
  context.
- **No SECURITY DEFINER.** This is a PostgreSQL-specific mechanism for RLS
  bypass. Not applicable to a TypeScript library.
- **Single config fetch for steps 3-5.** Fetch the relation config once
  and read all three fields (implied_by, computed_userset,
  tuple_to_userset) from the result.
- **Don't merge implied_by and computed_userset.** They are distinct OpenFGA
  concepts. `implied_by` means "relation X on the same object type implies this
  relation" (e.g., `channels_admin` implies `member`). `computed_userset` means
  "check a different relation on the same object" (used in GitHub model for
  `can_merge` -> `can_push`).
- **Don't skip condition evaluation on userset tuples.** Both direct tuples
  (step 1) and userset tuples (step 2) can have conditions. Evaluate before
  accepting or recursing.
- **Don't use Kysely types in core/.** The core package must remain
  database-agnostic. `@tsfga/core` never imports from `@tsfga/kysely`.
- **No default values for environment variables.** Read `process.env.VAR`
  directly, without `|| "fallback"`. The `.env` file is the single source of
  truth for defaults.
- **No raw SQL for DML in the adapter.** All adapter queries must use
  Kysely's type-safe query builder. The only exception is `sql` expressions
  *within* builder calls (e.g., `onConflict().expression(sql`...`)`).
  Full raw `sql` INSERT/SELECT queries bypass type checking and
  schema validation.
- **No `as` type assertions in production code.** Use control-flow
  narrowing (guards, early returns, local const captures) instead.
  The only acceptable `as` usage is `as const` for literal types.
- **No loose equality (`==` / `!=`).** Always use strict equality
  (`===` / `!==`). For nullish checks, use explicit
  `=== null || === undefined` or `??` / `?.` operators.
- **Validate JSON from the database at the adapter boundary.** JSON
  columns return `Json | null` from Kysely. Never cast with `as` to
  a domain type. Write a validation function that checks the shape
  and throws `InvalidStoredDataError` on mismatch.
- **No cross-package relative imports.** Use `@tsfga/core` or
  `@tsfga/kysely` package names for cross-package imports. Relative
  imports (`../`) are only for within the same package.

## References

- OpenFGA docs: https://openfga.dev/docs/modeling/getting-started
- OpenFGA conditions: https://openfga.dev/docs/modeling/conditions
- CEL spec: https://github.com/google/cel-spec
- `@marcbachmann/cel-js`: https://github.com/nicholasgasior/cel-js
- Kysely docs: https://kysely.dev/
- kysely-codegen: https://github.com/RobinBlomberg/kysely-codegen
- Turborepo docs: https://turbo.build/repo/docs
- Changesets docs: https://github.com/changesets/changesets
